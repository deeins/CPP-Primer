[TOC]

# 第六章 函数

## 6.1 函数基础

函数定义包括四个部分：返回类型、函数名、形参列表、函数体

使用<u>调用运算符()</u>来调用函数

#### 函数调用

流程：

1. 用实参初始化对应形参
2. 将控制权转移给被调用函数

此时主调函数的执行被暂时中断，被调函数开始执行

return语句的流程类似：

1. 返回值
2. 转移控制权

#### 形参列表

即使多个形参的类型一样，也要用分别用声明符来声明

任意两个形参不能同名

函数的最外层作用域中的局部变量也不能使用与函数形参一样的名字

### 6.1.1 局部对象

- 名字的作用域是程序文本的一部分，名字在其中可见
- 对象的生命周期是程序执行时间该对象存在的时间

形参和函数体内部的变量统称为局部变量，它会隐藏在外层作用域中同名的其他所有声明

#### 自动对象

只存在于块执行期间的对象

块结束后变为未定义

如果不传参给形参，且形参没有默认值，将执行默认初始化，内置类型此时由于是局部变量，所以会产生未定义的值

#### 局部静态对象

使用static关键字定义，第一次结果该声明语句时初始化，然后后续运行到此句的时候不再初始化，什么都不处理

这种对象的生命周期贯穿调用和之后的时间，直到程序终止才销毁

### 6.1.2 函数声明

<u>函数名字必须在使用之前声明</u>

声明不需要函数体，也不需要形参名字

### 6.1.3 分离式编译

分离式编译可以把程序分割到几个文件中去，每个文件独立编译：
	g++ test.cpp test2.cpp#同时编译两个文件

修改了单个文件只需要再编译该文件即可，不需要整个项目重新编译

编译器会将对象文件链接在一起生成可执行文件，对象文件的后缀为.o，上面的编译包含了链接过程，完整的编译过程：

​	g++ -c test.cpp#生成test.o文件

​	g++ -c test2.cpp#生成test2.o文件

​	g++ test.o test2.o -o main#生成main.exe文件

## 6.2 参数传递

当形参是引用类型时，称对应的<u>实参被引用调用</u>或者<u>函数被传引用调用</u>

非引用时，实参被传值调用，函数被传值调用

### 6.2.1 传值参数

指针形参会拷贝生成一个新的指针，但可以通过它间接访问所指向的对象

建议使用引用而不是指针，性能要好一些

### 6.2.2 传引用参数

使用引用类型作形参，不会创建新对象，也能对所引用的对象进行操作

使用引用能避免拷贝

类类型拷贝效率低下，所以引用类类型比较合适

#### 使用引用类型返回额外信息

一个函数只能返回一个值，但使用引用类型相当于返回了多个值，比如要统计一个单词在一个字符串中第一次出现位置，然后记录出现次数，这时可以使用一个cnt变量作为引用类型的形参，然后函数返回第一次出现位置

### 6.2.3 const形参和实参

形参的顶层const会被忽略，此时有无顶层const的函数会被编译器识别为同一个函数

```c++
void fun(int i);

void fun(const int i);//相同的函数
```



另外传入的实参无论是否是常量对象都可以

#### 指针或引用形参与const

可以使用非常量初始化一个底层const对象，但不能用底层const对象初始化非常量

普通引用必须用同类型的对象初始化，比如你不能把底层const对象拿去给普通引用初始化，指针同理

```c++
const int ci=0;
const int* p=&ci;
```

&ci相当于一个底层const指针

#### 尽量使用常量引用

<u>常量引用可以告诉使用者这个量不会被改变，另外初始化可以使用字面值，而普通引用作为形参则不能使用字面值</u>

### 6.2.4 数组形参

数组不允许被拷贝，所以不能将数组作为形参，但可以使用指向数组的指针来实现数组的传递

```c++
void fun(int i[]);
void fun(int *i);
void fun(int i[10]);
```

上面三种形式的声明是等价的，在形参列表中使用数组的形式会忽略掉数组的维度，将它视为指针

管理指针形参有三种常用技术

#### 使用标记指定数组长度

使用一个结束符来标志数组已经结束，例如C风格字符串使用'\0'作为结束标志

这种方式适用于结束标志不会与数组中的元素发生混淆的情况，像int类型的数组使用0作为结束标志，就会混淆

#### 使用标准库规范

传递指向首元素和尾后元素的指针，这种方法受到了标准库技术的启发

```c++
void fun(const int *beg,const int *end);
```

#### 显式传递一个表示数组大小的形参

使用end()和begin()函数得到的指针的差值即可得到数组的大小，传递此值即可

argc就是这样一个值，它作为传入main函数的C风格字符串的大小

#### 数组引用传参

```c++
void print(int (&arr)[10]);//表示对具有10个整型数据的数组的引用
```

上述声明引用的括号不能省，省去了的意思是将arr声明为了引用的数组，内部元素是引用类型

目前这种方式传入的数组的大小是固定的，后面会解释传入任意大小数组的方法

#### 传递多维数组

数组的第二维及后面的所有维度的大小都是数组维度的一部分，不能省略

```c++
void fun(int (*arr)[10]);//括号不能省略
void fun(int arr[][10]);//等价定义
```

### 6.2.5 main：处理命令行选项

假定main函数位于可执行文件prog内，在命令行使用以下语句可以向main函数传递一定大小的参数

prog -d -o ofile data0

其中prog是可执行文件的名字，后面的空格将每个元素分开，这些元素作为一个C风格字符串的数组被传入main函数

main函数要传入参数，要如此写

```c++
int main(int argc,char *argv[])
{
    ···
}
```

其中argc是传入元素的数量，argv是指向C风格字符串的指针

也可以写成这样

```c++
int main(int argc,char** argv)
{
    ···
}
```

argv[0]="prog";//也可以指向一个空字符串

argv[1]="-d";

以此类推，最后以0结尾

即argv[5]=0;

### 6.2.6 含有可变形参的函数

标题的意思是参数数量可变，类型一样的情况。此时可以使用initializer_list的标准库类型来传递参数，这是一个模板

支持的操作：

```c++
initializer_list<T> lst;//默认初始化
initializer_list<T> lst{a,b,c...};//列表初始化,其中的元素是const的值,所以传参可以是字面值
lst2(lst);//拷贝
lst2=lst;//这两种方式等价，是浅拷贝
lst.size();//返回列表元素的数量
lst.begin();
lst.end();
```

传入参数的使用方式是使用花括号括住参数列表：

```c++
void fun(initalizer_list<string> lst)
{
    ...
}
...
fun({"function",expected,actual});
```

因为有begin和end成员，所以可以使用范围for循环

## 6.3 返回类型和return语句

中间略

### 6.3.3 返回数组指针

返回值要想是指向数组的指针，可以使用别名来简化声明

```c++
typedef int arrT[10];//表示这是个含有10个整数的数组的类型别名
arrT* fun(int i);
//不使用别名
int (*fun(int i))[10];//维度要在后面
```

#### 使用尾置返回类型

```c++
auto fun(int i) -> int (*) [10]
```

#### 使用decltype

如果已知返回的是那个数组，那么可以使用decltype来推测类型

```c++
int odd={...};
decltype(odd) *fun(int i);//decltype返回数组类型，所以还要加*表示返回指针
```

## 6.4 函数重载

函数重载：同名函数，不同参数数量或类型，但返回类型要一样

顶层const会与普通类型的同类型参数重定义，底层则不会

函数重载有时会利用const_cast<T>来为对象添加const，比如传入类型和返回类型全是cosnt string&的一个函数，可以将它重载为传入类型和返回类型都是string&类型的函数，在第二个函数内部可以嵌套第一个函数，实参在传入时使用const_cast即可传入string&对象

```c++
const string& shorter_string(const string& s1,const string& s2)
{
    ...
}
string& shorter_string(string& s1,string& s2)
{
    auto& r=shorter_string(const_cast<const string&>(s1),const_cast<const string&>(s2));
    ...
}
```

#### 调用重载函数

- 找到最佳匹配
- 无匹配
- 二义性调用，每一个都不是最佳，但可以匹配

### 6.4.1 重载与作用域

在内层作用域中声明明在，会隐藏外层作用域中的同名实体。在不同作用域中无法重载函数名：

比如有一个read函数，而fooBar函数中定义一个名为read的变量，然后这个函数中将无法调用read函数，因为被隐藏了；另外还定义了一个名为print的函数，在fooBar函数中尝试定义一个名为print的函数，将无法在这个函数中调用外层的print，无法达到重载的效果

函数调用时，首先会寻找局部作用的同名变量，如果找到了就会忽略掉外层的同名实体

### 6.5 特殊用途语言特性

### 6.5.1 默认实参

默认实参必须在形参列表的最右边

### 6.5.2 内联函数和constexpr函数

内联函数<u>在返回类型前</u>使用inline关键词来声明，它可以节省开销，不需要进行函数执行时的保存数据的操作，它会内联地展开，即相当于直接在调用位置插入返回值，不进行多余操作
