// chapter3.5_array.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//数组

#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main()
{
    //3.5.1定义和初始化数组
    //数组大小不变，一开始必须计算好大小
    // 对于某些特殊程序性能可能较好，但不够灵活
    // 数组的维度，即下标运算符中的数，必须是一个常量表达式，最好用constexpr声明，const有些情况不行
    // 编译时维度是已知的
    // 定义数组时必须指定类型，不能用auto关键词推测数组类型
    // 数组的初始化可以采用列表初始化，此时可以忽略维度
    int iarr[] = { 1,2,3 };
    // 字符数组有一定特殊性
    // 使用列表初始化，其结尾一般要手动补充空字符'\0'
    char carr[] = { 'c','+','+','\0' };
    //使用字符串字面量初始化则自动补充空字符
    char carr2[] = "c++";
    // !!数组不允许拷贝和赋值，即不能用数组为数组初始化和进行赋值操作
    // 
    // 数组有着复杂的初始化操作
    int iarr2[10] = {};//默认初始化
    //使用解引用符和引用时务必使用圆括号()，它们优先级比较低
    int (*parr)[10] = &iarr2;//指向大小为10的数组的指针
    int (&arr_ref)[10] = iarr2;//对大小为10的数组的指针进行引用
    //
    // 
    // 3.5.2  访问数组元素
    // 数组下标的类型是size_t，定义在头文件cstddef中
    // 数组的下标运算符是C++直接定义的，不用头文件
    // 数组也可以使用范围for语句
    for (auto c : *parr)
    {
        cout << c << ' ';
    }
    cout << endl;
    // 
    // 
    // 3.5.3  指针和数组
    // 使用数组时，编译器会把它转换为指针
    // 数组名相当于数组首地址
    // 使用auto定义变量，初始值为数组时得到的变量是一个指针
    auto iarr3(iarr2);//iarr3的类型为int*
    auto iarr4(&iarr2[2]);//同上
    //！！使用decltype推测数组得到的变量是数组，不会得到指针
    decltype(iarr2) iarr5 = {};//iarr5是一个大小为10的数组，和iarr2一样
    // 指针也是迭代器，获取数组的尾指针的需要用到[]
    int* p = &iarr2[10];//该指针指向iarr2末尾，是不存在的值
    //上述得到尾指针的方法极易犯错，因为位置可能判断错
    // C++11引入了新的方法
    // begin和end函数来得到数组的首尾指针
    // 但它们不是数组的成员函数
    // 所以调用方式和迭代器不一样
    int* p2 = begin(iarr2);//首指针
    int* p3 = end(iarr2);//尾指针
    // 指针能进行的操作和迭代器一样
    // 且指针和指针也不能相加
    // 指针相减得到的值是两个指针的距离，带符号
    // 它的类型是ptrdiff_t，定义在头文件cstddef中，和size_t一样
    // 不能比较指向不同对象的两个指针
    // 
    // 解引用和指针运算的交互
    // *(ia+4)相当于ia[4]
    // 标准库中下标必须是无符号类型
    // 而内置类型没有这个限制
    // 可以带符号
    int* p4 = iarr2 + 2;
    p4[-2] = 10;//下标可以为负
    // 
    // 
    // 3.5.4  C风格字符串
    // C风格字符串是字符数组后有'\0'的字符串
    // 用起来不是很方便，而且极易引发程序漏洞
    // 它的操作定义在头文件cstring中
    // 这些操作都是基于末尾字符尾'\0'执行的，所以很不安全，忘写空字符时会一直访问到第一个空字符
    // 这些操作有
    // strlen(p)
    // strcmp(p1,p2)
    // strcat(p1,p2)
    // strcpy(p1,p2)
    // 
    // 总结来说尽量使用string对象，而不是C风格字符串
    // 
    // 
    // 3.5.5  与旧代码的接口
    // 可以使用以空字符结尾的字符数组来初始化string对象或为string对象赋值
    // string对象的加法运算允许其中一个为以空字符结尾的字符数组，复合赋值运算允许右值为以空字符结尾的字符数组
    // 反之，以上不成立
    // 为了让string对象能初始化字符数组
    // C++中string定义了一个名为c_str的成员函数
    string s = "c++";
    const char* carr3 = s.c_str();
    //它很不稳定，一旦s发生改变carr就会失效
    // 
    // 允许用数组初始化vector对象
    // 要指明首尾，首尾可以自定义
    vector<char> cvec(begin(carr), end(carr));
    // 
    // ！！C++程序应多使用容器和迭代器，避免使用数组和指针
    // 
    //
}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
