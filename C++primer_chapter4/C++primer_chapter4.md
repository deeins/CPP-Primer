# 第四章 表达式

## 4.1 基础

### 4.1.1基础概念

#### 左值和右值

<u>简便记忆</u>：左值能用于赋值语句的左侧，也能在右侧；右值只能在右侧

常量左值不能用在赋值语句左侧

<u>归纳</u>：当一个对象用于作左值时，使用的是对象的身份（内存）；作右值时，使用的是值（内容）

左值能转换成右值

<u>需要用到左值的运算符：</u>

1. 赋值运算符=，利用一个非常量左值作左侧对象，返回左值

2. 取地址符&，返回一个指向作用对象的指针，这个指针是右值

   ```c++
   int a=0;
   int p=&a;//&a是一个右值
   ```

3. 内置解引用运算符*、下标运算符[]、迭代器解引用运算符\*、string和vector的下标运算符[]求值结果是左值

   ```c++
   *p=1;
   int b[10]={};
   string str="abc";
   str[0]='d';//sring对象可以通过下标运算符处理单个元素
   ```

4. 内置类型和迭代器的++、--的前置版本作用于左值，结果返回左值，**后置版本返回的不是左值，不能修改其值**

decltype注意事项：

​	使用左值作为推测对象，那么返回引用类型，结合上面运算符的返回值有以下两个特别的例子：

```c++
decltype(*p);//返回引用类型int&，p是上面定义的int指针
decltype(&p);//返回int**，指向指针的指针
```

### 4.1.2 优先级和结合律

在一个复合表达式中，优先级高的先运算；**如果优先级一样，那么顺序由结合律决定**，括号始终优先计算

对于结合律对顺序的影响，有以下例子：

```c++
cOUt<< "abc" << "def";
```

这里的<<运算符是左结合律的，所以会先读入"abc"，即左结合律优先计算表达式的左侧

条件运算符是典型的右结合律：

```c++
string final_grade=grade>90 ? "high pass":grade>75 ? "pass":grade>60 ? "low pass":"fail";
```

上面的条件表达式会优先运算出右侧表达式的值，即从右向左计算，简化一下，上述表达式可以看作是按顺序书写的三个条件运算符，会优先计算第三个条件运算符，**只有条件运算符的表达式才使用结合性判断顺序，因为没有与条件运算符优先级相同的运算符**

### 4.1.3 求值顺序

```c++
int i=f1()*f2();
```

上述表达式有两个函数，分别是f1和f2，它们必定会在乘法之前调用，但谁先谁后无法得知

对于没有指定执行顺序的运算符，如果两个表达式指向并修改了同一个对象，将引发错误并产生未定义的行为，如下<<运算符没有指定何时以及如何对运算对象求值**（实际测试没有产生未定义行为，为什么？）**

```c++
int i=0;
cout << i << ' ' << ++i << endl;//以C++11的标准来说是未定义语句，在最新版本的编译器中执行结果是1 1
//使用后置++那么结果是1 0
```

有明确求值顺序的运算符，先左后右："&&"、"||"、"?:"、","

#### 求值顺序、优先级、结合律

运算对象的求值顺序与优先级、结合律无关，f()+g()*h()+j()中：

- 优先级规定，g()的返回值和h()的返回值相乘
- 结合律规定，f()的返回值优先和乘积相加
- **函数的调用顺序没有明确规定**

如果它们是无关函数，既不改变同一对象状态也不执行IO任务，那么顺序不受限制。否则它是一条错误的表达式，将产生未定义行为

## 4.2 算术运算符

算术运算符都满足左结合律

表达式求值前，小的整数类型都会转换为较大的

%取余对象必须是整型

## 4.3 逻辑和关系运算符

只有!非是右结合律，因为它是单目的，且运算对象在右边

逻辑与和非都有短路行为

## 4.4 赋值运算符

满足右结合律，先算右侧

```c++
int j,k;
j=k=2;//合法，都能被赋值
```



左侧对象必须是可修改的左值

## 4.5 递增和递减运算符

作用与左值

前置版本返回左值，后置版本返回对象原始值的副本，是右值

后置版本会保存原始值，所以性能上比前置版本差，**尽量使用前置版本**

后置版本可用于简化语句

```c++
int a[10]={};
int ptr=a;
while(ptr!=end(a))
    cout << *ptr++ << endl;//输出当前值并指向下一个元素
```

## 4.6 成员访问运算符

点运算符和箭头运算符都可以用于成员访问

(*iter).men等效于iter->men（iter是迭代器或者指针）

解引用运算符的优先级低于点运算符，所以要加括号

箭头运算符返回的始终是左值，点运算符版本返回的成员是左值还是右值，以所属对象为标准

## 4.7 条件运算符

右结合律

条件运算符优先级小于<<，优先级非常低

条件运算符可以嵌套，具体可以见4.1中例子，但最好不要超过三层

## 4.8 位运算符

理解不是很到位，暂时不作总结

## 4.9 sizeof运算符

返回一条表达式或一个类型名字所占字节数

满足右结合律

所得的值类型为size_t和数组的下标类型一样

sizeof和*的优先级一样，有这样一个例子

```c++
sizof *p;
```

​	上面的例子中，由于sizeof是右结合律，所以会先计算*p

可以作用于无效的指针，如空指针，因为sizeof运算符不会运算对象的实际值

sizeof运算符可以用来获取类成员的大小，它不会把数组当成指针处理，sizeof(数组)会返回数组的大小，而使用指针指向数组，然后sizeof(这个指针)则会返回指针的大小

## 4.10 逗号运算符

先算左侧，再算右侧，返回右侧的值

## 4.11 类型转换

隐式转换，自动执行的转换

强制类型转换：

static_cast<type>(expression)：将一种类型强制转换为另一种类型

const_cast<type>(expression)：去掉表达式的底层const，type应与表达式相同

reinterpret_cast<type>(expression)：将一种类型解释为另一种类型，暂时不会用

建议：**尽量不使用强制类型转换**

## 4.12 运算符优先级表

<img src="C:\Users\hp\Documents\Tencent Files\1592743769\FileRecv\MobileFile\IMG20230803170820.jpg" alt="IMG20230803170820" style="zoom:10%;" />

<img src="C:\Users\hp\Documents\Tencent Files\1592743769\FileRecv\MobileFile\IMG20230803170832.jpg" alt="IMG20230803170832" style="zoom:10%;" />
